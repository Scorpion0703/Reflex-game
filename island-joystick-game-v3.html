<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Island Game • v3 (Animated Player)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#8ecf8a;touch-action:none;overscroll-behavior:none;font-family:system-ui}
  canvas{display:block;width:100%;height:100%}
  /* Virtual Joystick (no scroll) */
  #joy,#knob{position:fixed;border-radius:50%;z-index:10}
  #joy{bottom:28px;left:28px;width:150px;height:150px;background:rgba(255,255,255,.18);border:2px solid rgba(255,255,255,.35);backdrop-filter:blur(8px)}
  #knob{width:70px;height:70px;left:66px;top:calc(100% - 93px);transform:translateY(-50%);background:#fff;pointer-events:none;border:0;border-radius:50%}
  #hud{position:fixed;left:10px;top:10px;z-index:11;background:rgba(255,255,255,.15);border:1px solid rgba(255,255,255,.25);padding:6px 10px;border-radius:10px;backdrop-filter:blur(8px);font-size:14px}
</style>
</head>
<body>
<div id="hud">Links tippen & ziehen → laufen • Kamera folgt</div>
<div id="joy" aria-label="Joystick"></div>
<div id="knob"></div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* ====== Renderer / Scene / Camera ====== */
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x8ecf8a);

const camera=new THREE.PerspectiveCamera(65,innerWidth/innerHeight,0.1,500);
camera.position.set(0,6,10);

/* ====== Lights ====== */
scene.add(new THREE.HemisphereLight(0xc9f7ff,0x316644,0.9));
const sun=new THREE.DirectionalLight(0xffffff,0.9); sun.position.set(6,10,4); sun.castShadow=false; scene.add(sun);

/* ====== Ground ====== */
const ground=new THREE.Mesh(
  new THREE.CircleGeometry(80,64),
  new THREE.MeshStandardMaterial({color:0x77c06b, roughness:0.95, metalness:0})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

/* ====== Simple toon material helper ====== */
const toon=(hex)=> new THREE.MeshStandardMaterial({color:hex, roughness:0.35, metalness:0, emissive:0x000000});

/* ====== Player (hierarchisch, animiert) ====== */
const player=new THREE.Group();
scene.add(player);
player.position.y=0.0;

const body=new THREE.Mesh(new THREE.CapsuleGeometry(0.6,1.1,8,16), toon(0x6f5df6));
body.position.y=1.35;
const head=new THREE.Mesh(new THREE.SphereGeometry(0.5,24,24), toon(0xffe0bd));
head.position.y=2.4;

function limb(len=1, thick=0.22, color=0x444444){
  const g=new THREE.CapsuleGeometry(thick,len,6,12);
  const m=new THREE.Mesh(g, toon(color));
  return m;
}
// Arme
const armL=new THREE.Group(), armR=new THREE.Group();
const upperL=limb(0.8,0.17,0x403a3a), upperR=limb(0.8,0.17,0x403a3a);
upperL.position.y=1.5; upperR.position.y=1.5;
upperL.position.x= 0.62; upperR.position.x=-0.62;
upperL.rotation.z= Math.PI*0.5; upperR.rotation.z= Math.PI*0.5;
armL.add(upperL); armR.add(upperR);
// Beine
const legL=new THREE.Group(), legR=new THREE.Group();
const lowerL=limb(1.0,0.22,0x2d2d2d), lowerR=limb(1.0,0.22,0x2d2d2d);
lowerL.position.y=0.5; lowerR.position.y=0.5;
lowerL.position.x= 0.28; lowerR.position.x=-0.28;
legL.add(lowerL); legR.add(lowerR);

player.add(body, head, armL, armR, legL, legR);

/* ====== Joystick (no scroll) ====== */
const JOY_R=75, KNOB_R=35;
const joy=document.getElementById('joy'); const knob=document.getElementById('knob');
let joyOn=false, joyCX=0, joyCY=0, jx=0, jy=0;

function centerKnob(cx,cy){ knob.style.left=(cx-KNOB_R)+'px'; knob.style.top=(cy-KNOB_R)+'px'; }
function setKnob(cx,cy,x,y){
  const dx=x-cx, dy=y-cy, dist=Math.min(KNOB_R,Math.hypot(dx,dy)), ang=Math.atan2(dy,dx);
  knob.style.left=(cx+Math.cos(ang)*dist-KNOB_R)+'px';
  knob.style.top =(cy+Math.sin(ang)*dist-KNOB_R)+'px';
  jx = dist<6?0:dx/KNOB_R;   // -1..1
  jy = dist<6?0:dy/KNOB_R;   // -1..1
}
joy.addEventListener('touchstart',e=>{
  const t=e.changedTouches[0], r=joy.getBoundingClientRect();
  joyOn=true; joyCX=r.left+JOY_R; joyCY=r.top+JOY_R; centerKnob(joyCX,joyCY); setKnob(joyCX,joyCY,t.clientX,t.clientY);
  e.preventDefault();
},{passive:false});
joy.addEventListener('touchmove',e=>{
  if(!joyOn) return; const t=e.changedTouches[0]; setKnob(joyCX,joyCY,t.clientX,t.clientY); e.preventDefault();
},{passive:false});
joy.addEventListener('touchend',e=>{ joyOn=false; jx=jy=0; const r=joy.getBoundingClientRect(); centerKnob(r.left+JOY_R,r.top+JOY_R); e.preventDefault(); },{passive:false});
joy.addEventListener('touchcancel',e=>{ joyOn=false; jx=jy=0; const r=joy.getBoundingClientRect(); centerKnob(r.left+JOY_R,r.top+JOY_R); e.preventDefault(); },{passive:false});

/* ====== Keyboard fallback ====== */
const keys={}; addEventListener('keydown',e=>keys[e.code]=true); addEventListener('keyup',e=>keys[e.code]=false);

/* ====== Movement + Walk animation ====== */
let vx=0, vz=0, phase=0; // phase für Beinschwingen
const SPEED=6, ACC=30, FRI=0.86;

function updateMovement(dt){
  // Input
  let ax=(keys['KeyD']||keys['ArrowRight']?1:0)-(keys['KeyA']||keys['ArrowLeft']?1:0);
  let az=(keys['KeyS']||keys['ArrowDown']?1:0)-(keys['KeyW']||keys['ArrowUp']?1:0);
  if(joyOn){ ax=jx; az=jy; }

  // Beschleunigung + Dämpfung
  vx += ax*ACC*dt; vz += az*ACC*dt;
  vx *= FRI; vz *= FRI;

  // begrenzen
  const len=Math.hypot(vx,vz); const max=SPEED;
  if(len>max){ vx = vx/len*max; vz = vz/len*max; }

  // Position
  player.position.x += vx*dt;
  player.position.z += vz*dt;

  // Blickrichtung
  const sp=Math.hypot(vx,vz);
  if(sp>0.02){ const yaw=Math.atan2(vz,vx); player.rotation.y = -yaw + Math.PI/2; }

  // Kamera follow (weich)
  const camTarget = new THREE.Vector3(player.position.x+6, 6, player.position.z+9);
  camera.position.lerp(camTarget, 0.08);
  camera.lookAt(player.position.x, 1.4, player.position.z);

  // === Walk animation ===
  const speedNorm = Math.min(1, sp / max);          // 0..1
  const freq = 9;                                   // Schrittfrequenz
  phase += speedNorm * freq * dt * Math.PI;         // animiert nur bei Bewegung

  // Beine schwingen gegenläufig
  const swing = Math.sin(phase) * 0.6 * speedNorm;
  legL.rotation.x =  swing;
  legR.rotation.x = -swing;

  // Arme gegenläufig zu Beinen
  armL.rotation.x = -swing * 0.7;
  armR.rotation.x =  swing * 0.7;

  // Body Bobbing
  body.position.y = 1.35 + Math.abs(Math.sin(phase))*0.05*speedNorm;
  head.position.y = 2.4  + Math.abs(Math.sin(phase+0.6))*0.05*speedNorm;
}

/* ====== Resize ====== */
addEventListener('resize',()=>{
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
});

/* ====== Loop ====== */
let last=performance.now();
function loop(t){
  const dt=Math.min(0.033,(t-last)/1000); last=t;
  updateMovement(dt);
  renderer.render(scene,camera);
  requestAnimationFrame(loop);
}
loop(last);
</script>
</body>
</html>
