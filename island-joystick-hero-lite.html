<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Island Hero â€¢ LITE (Instant Start)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#86c98c;touch-action:none;overscroll-behavior:none;font-family:system-ui}
  canvas{display:block;width:100%;height:100%}
  #hud{position:fixed;left:10px;top:10px;z-index:20;background:rgba(255,255,255,.15);border:1px solid rgba(255,255,255,.25);padding:6px 10px;border-radius:10px;backdrop-filter:blur(8px);font-size:14px}
  #hud b{font-weight:700}
  /* Floating Joystick */
  #joyBase,#joyKnob{position:fixed;border-radius:50%;pointer-events:none;z-index:15;opacity:0;transition:opacity .08s}
  #joyBase{width:160px;height:160px;border:2px solid rgba(124,248,255,.45);background:rgba(124,248,255,.10);backdrop-filter:blur(6px);transform:translate(-50%,-50%)}
  #joyKnob{width:90px;height:90px;border:2px solid rgba(124,248,255,.9);background:rgba(124,248,255,.28);backdrop-filter:blur(8px);transform:translate(-50%,-50%)}
</style>
</head>
<body>
<div id="hud">ðŸŸ¡ <b id="score">0</b> â€¢ <span id="stat">Sofort startklar â€” Modell wird leise nachgeladenâ€¦</span></div>
<div id="joyBase"></div><div id="joyKnob"></div>
<canvas id="c"></canvas>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import {OrbitControls} from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

// ============ Renderer/Scene ============
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({
  canvas, antialias:true, powerPreference:"high-performance"
});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x86c98c);

// Lights minimal (schnell)
scene.add(new THREE.HemisphereLight(0xc9f7ff, 0x316644, 0.9));

// Camera/Controls
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 600);
camera.position.set(0,6,14);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0,1.4,0);
controls.maxPolarAngle = Math.PI*0.49;
controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

// Ground (ein Mesh)
const ground = new THREE.Mesh(
  new THREE.CircleGeometry(110, 64),
  new THREE.MeshStandardMaterial({color:0x78bd70, roughness:0.95, metalness:0})
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// ============ Sofort spielbarer Placeholder-Player ============
const heroGroup = new THREE.Group(); scene.add(heroGroup);
let hasRealModel = false;

const placeholder = new THREE.Group();
const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.6,1.2,8,12),
  new THREE.MeshStandardMaterial({color:0x6f5df6, roughness:0.4}));
body.position.y = 1.4;
const head = new THREE.Mesh(new THREE.SphereGeometry(0.48, 20, 20),
  new THREE.MeshStandardMaterial({color:0xffe0bd, roughness:0.4}));
head.position.y = 2.45;
const legL = new THREE.Mesh(new THREE.CapsuleGeometry(0.2,0.9,6,10), new THREE.MeshStandardMaterial({color:0x2d2d2d}));
const legR = legL.clone();
legL.position.set( 0.26, 0.45, 0); legR.position.set(-0.26, 0.45, 0);
const armL = new THREE.Mesh(new THREE.CapsuleGeometry(0.16,0.7,6,10), new THREE.MeshStandardMaterial({color:0x403a3a}));
const armR = armL.clone(); armL.position.set( 0.62, 1.5, 0); armR.position.set(-0.62, 1.5, 0);
placeholder.add(body, head, legL, legR, armL, armR);
heroGroup.add(placeholder);

// Simple walk anim fÃ¼r Placeholder
let walkPhase = 0;

// ============ Joystick ============
const JOY_MAX = 70;
const joyBase = document.getElementById('joyBase');
const joyKnob = document.getElementById('joyKnob');
let joyActive=false, joyId=null, joyCX=0, joyCY=0, jx=0, jy=0;

function showJoy(x,y){ joyBase.style.left=x+'px'; joyBase.style.top=y+'px'; joyKnob.style.left=x+'px'; joyKnob.style.top=y+'px'; joyBase.style.opacity=1; joyKnob.style.opacity=1; }
function hideJoy(){ joyBase.style.opacity=0; joyKnob.style.opacity=0; }
function setJoyVector(cx,cy,x,y){
  const dx=x-cx, dy=y-cy, d=Math.hypot(dx,dy), a=Math.atan2(dy,dx), r=Math.min(JOY_MAX,d);
  joyKnob.style.left=(cx+Math.cos(a)*r)+'px';
  joyKnob.style.top =(cy+Math.sin(a)*r)+'px';
  jx = (d<8)?0:dx/JOY_MAX; jy = (d<8)?0:dy/JOY_MAX;
}
addEventListener('touchstart',(e)=>{
  for(const t of e.changedTouches){
    if(joyActive) continue;
    if(t.clientX > innerWidth*0.6) continue;
    joyActive=true; joyId=t.identifier; joyCX=t.clientX; joyCY=t.clientY; showJoy(joyCX,joyCY);
    setJoyVector(joyCX,joyCY,t.clientX,t.clientY);
    e.preventDefault();
  }
},{passive:false});
addEventListener('touchmove',(e)=>{
  if(!joyActive) return;
  for(const t of e.changedTouches){
    if(t.identifier===joyId){ setJoyVector(joyCX,joyCY,t.clientX,t.clientY); e.preventDefault(); }
  }
},{passive:false});
function endJoyById(id){ if(joyId!==id) return false; joyActive=false; joyId=null; jx=0; jy=0; hideJoy(); return true; }
addEventListener('touchend',   e=>{ for(const t of e.changedTouches){ if(endJoyById(t.identifier)) e.preventDefault(); } }, {passive:false});
addEventListener('touchcancel',e=>{ for(const t of e.changedTouches){ if(endJoyById(t.identifier)) e.preventDefault(); } }, {passive:false});

// Keyboard fallback
const keys={}; addEventListener('keydown',e=>keys[e.code]=true); addEventListener('keyup',e=>keys[e.code]=false);

// Movement state
let vx=0, vz=0, vy=0; const ACC=40, SPEED_WALK=3.6, SPEED_RUN=6.6, GRAV=30, JUMP=10;

// Items (klein gehalten, schnell)
const items=[]; const scoreEl=document.getElementById('score');
function addCoin(x,z){
  const m = new THREE.Mesh(new THREE.TorusGeometry(0.6,0.2,12,24),
    new THREE.MeshStandardMaterial({color:0xffd250, emissive:0x7a4a00, emissiveIntensity:0.6}));
  m.position.set(x,1,z); m.userData.type='coin'; scene.add(m); items.push(m);
}
for(let i=0;i<12;i++){ addCoin((Math.random()*2-1)*70,(Math.random()*2-1)*70); }
let score=0;

// Simple particles
const sparks=[];
function sparkBurst(pos,color=0xffd250,n=18){
  for(let i=0;i<n;i++){
    const p=new THREE.Mesh(new THREE.SphereGeometry(0.06,6,6),
      new THREE.MeshStandardMaterial({color, emissive:color, emissiveIntensity:0.9, roughness:1}));
    p.position.copy(pos); p.userData={vx:(Math.random()*2-1)*3, vy:Math.random()*3, vz:(Math.random()*2-1)*3, life:.6+Math.random()*.3};
    scene.add(p); sparks.push(p);
  }
}

// Tiny audio (instant)
let AC=null; const statEl=document.getElementById('stat');
function audio(){ if(!AC) AC=new (window.AudioContext||window.webkitAudioContext)(); return AC; }
function bip(f=880,t='sine',d=.09,v=.18){ try{ const c=audio(), g=c.createGain(), o=c.createOscillator(), T=c.currentTime;
  g.gain.value=.0001; o.type=t; o.frequency.value=f; o.connect(g); g.connect(c.destination);
  g.gain.exponentialRampToValueAtTime(v, T+.01); g.gain.exponentialRampToValueAtTime(.0001, T+d);
  o.start(T); o.stop(T+d+.02);}catch{} }
document.addEventListener('touchstart',()=>{ try{audio().resume();}catch{} },{once:true,passive:true});
document.addEventListener('click',()=>{ try{audio().resume();}catch{} },{once:true,passive:true});

// ====== Progressive movement & anim ======
function moveVector(){
  const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
  const right   = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();
  let ax=(keys['KeyD']||keys['ArrowRight']?1:0)-(keys['KeyA']||keys['ArrowLeft']?1:0);
  let az=(keys['KeyW']||keys['ArrowUp']?   1:0)-(keys['KeyS']||keys['ArrowDown']?1:0);
  if(joyActive){ ax=jx; az=-jy; }
  const v = new THREE.Vector3();
  if(ax||az){ v.addScaledVector(right,ax); v.addScaledVector(forward,az); v.normalize(); }
  return v;
}
let stepAccum=0;

function update(dt){
  // movement
  const dir = moveVector();
  const mag = Math.hypot(jx,jy);
  const target = (mag>0.7 || keys['ShiftLeft']) ? SPEED_RUN : SPEED_WALK;
  const tx = dir.x*target, tz = dir.z*target;
  vx += (tx - vx) * Math.min(1, ACC*dt);
  vz += (tz - vz) * Math.min(1, ACC*dt);

  heroGroup.position.x += vx*dt;
  heroGroup.position.z += vz*dt;

  const sp = Math.hypot(vx,vz);
  if(sp>0.02){ const yaw=Math.atan2(vz,vx); heroGroup.rotation.y=-yaw+Math.PI/2; }

  // camera follow
  const camTarget = new THREE.Vector3(heroGroup.position.x+7, 6, heroGroup.position.z+10);
  camera.position.lerp(camTarget, 0.08);
  controls.target.lerp(new THREE.Vector3(heroGroup.position.x,1.4,heroGroup.position.z),0.2);
  controls.update();

  // placeholder walk anim
  if(!hasRealModel){
    const speedNorm = Math.min(1, sp / SPEED_RUN);
    walkPhase += speedNorm * 9 * dt * Math.PI;
    const swing = Math.sin(walkPhase) * 0.6 * speedNorm;
    legL.rotation.x =  swing;
    legR.rotation.x = -swing;
    armL.rotation.x = -swing*0.7;
    armR.rotation.x =  swing*0.7;
    body.position.y = 1.4 + Math.abs(Math.sin(walkPhase))*0.05*speedNorm;
    head.position.y = 2.45 + Math.abs(Math.sin(walkPhase+0.6))*0.05*speedNorm;

    // Soft footstep ping
    if(sp>0.6){ stepAccum += sp*dt; if(stepAccum>1){ stepAccum=0; bip(180,'sawtooth',.05,.05);} } else stepAccum=0;
  }

  // pick-ups
  for(const it of items){
    if(!it.visible) continue;
    if(heroGroup.position.distanceTo(it.position) < 1.6){
      it.visible=false; sparkBurst(it.position, 0xffd250, 22); score++; scoreEl.textContent=score; bip(1000,'square',.08,.2); bip(1400,'sine',.08,.12);
    }
  }

  // particles
  for(let i=sparks.length-1;i>=0;i--){
    const p=sparks[i]; p.userData.life-=dt; if(p.userData.life<=0){ scene.remove(p); sparks.splice(i,1); continue; }
    p.position.x+=p.userData.vx*dt; p.position.y+=p.userData.vy*dt; p.position.z+=p.userData.vz*dt; p.userData.vy-=9.8*dt*0.6;
    p.material.emissiveIntensity = Math.max(0, p.userData.life*1.2);
  }
}

// ====== Progressive model load (nachtrÃ¤glich ersetzen) ======
(async function loadRealModel(){
  // Loader erst NACH Start importieren (spart initialen Parse)
  const [{GLTFLoader}, {DRACOLoader}] = await Promise.all([
    import("https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"),
    import("https://unpkg.com/three@0.160.0/examples/jsm/loaders/DRACOLoader.js"),
  ]);
  const loader = new GLTFLoader();
  const draco = new DRACOLoader();
  draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/");
  loader.setDRACOLoader(draco);

  const MODEL_URL = "https://threejs.org/examples/models/gltf/Soldier.glb"; // schnell verfÃ¼gbar; kann spÃ¤ter ersetzt werden
  try{
    const gltf = await loader.loadAsync(MODEL_URL, (e)=>{
      if(e.total) statEl.textContent = `Lade Figurâ€¦ ${Math.round(e.loaded/e.total*100)}%`;
      else statEl.textContent = `Lade Figurâ€¦`;
    });
    const real = gltf.scene;
    real.traverse(o=>{ if(o.isMesh){ o.frustumCulled=true; o.castShadow=false; o.receiveShadow=false; }});
    real.scale.set(1,1,1);
    // gleiche Position/Rotation Ã¼bernehmen
    real.position.copy(heroGroup.position);
    real.rotation.copy(heroGroup.rotation);

    // Anim
    const mixer = new THREE.AnimationMixer(real);
    const actions = {};
    gltf.animations.forEach(clip=> actions[clip.name] = mixer.clipAction(clip));
    let active=null; const play=(n,fade=.15)=>{ if(!actions[n]) return; const next=actions[n]; if(active!==next){ next.reset().play(); if(active) active.crossFadeTo(next,fade,false); active=next; }};
    // anim update im loop einhÃ¤ngen
    let lastT=performance.now();
    function animateMix(){
      const now=performance.now(), dt=Math.min(0.033,(now-lastT)/1000); lastT=now;
      mixer.update(dt);
      // Geschwindigkeit ermitteln aus vx/vz
      const sp=Math.hypot(vx,vz);
      if(sp<0.2) play('Idle'); else if(sp< (SPEED_WALK+SPEED_RUN)/2) play('Walk'); else play('Run');
      requestAnimationFrame(animateMix);
    }
    animateMix();

    // Placeholder ersetzen
    scene.remove(heroGroup);           // alten Container raus
    const newGroup = new THREE.Group();
    newGroup.add(real);
    scene.add(newGroup);
    // auf neue Referenz umstellen
    heroGroup.position.copy(real.position);
    heroGroup.rotation.copy(real.rotation);
    // Aber wir nehmen newGroup als Container weiter:
    heroGroup.children.length=0;
    heroGroup.add(real);

    hasRealModel = true;
    statEl.textContent = 'Figur geladen âœ”ï¸Ž';
  }catch(err){
    console.warn('Model load error', err);
    statEl.textContent = 'Figur konnte nicht geladen werden â€“ spiele mit Platzhalter weiter.';
  }
})();

// ===== Resize & Loop =====
addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
});
let last = performance.now();
function loop(t){
  const dt = Math.min(0.033, (t-last)/1000); last=t;
  update(dt);
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
loop(last);
</script>
</body>
</html>
